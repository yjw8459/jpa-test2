단방향 연관관계
객체와 테이블 연관관계의 차이 이해
객체의 참조와 테이블의 외래 키를 매핑
방향 : 단방향, 양방향
다중성 : 다대일, 일대다, 일대일 다대다 이해
연관관계의 주인 : 객체 양방향 연관관계는 관리 주인이 필요

연관관계가 필요한 이유
'객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.'

양방향 연관관계
쌍방의 객체에서 get으로 참조되는 경우
테이블의 연관관계는 방향의 개념이 없다. 쌍방의 키로 쌍방의 키로 쌍방의 데이터를 알 수 있기 때문이다.
하지만 객체는 방향의 개념이 있다. ex)member.getTeam()은 되지만, team.getMember()는 될 수 없다.
다대일의 쌍방 참조를 하려면 Member는 Team을 Team은 List<Member>를 가지고 있어야 한다.
List<Member> members = findMember.getTeam().getMembers(); //멤버의 팀에 소속된 멤버들
객체는 가급적 단방향이 좋다.

연관관계의 주인과 mappedBy
객체와 테이블이 관계를 맺는 차이
객체의 연관관계 = 2개
    회원 -> 팀 연관관계 1개(단방향)
    팀 -> 회원 연관관계 1개(단방향)
    회원에서 팀을 찾으려면 회원 객체는 팀의 참조 값을 가지고 있어야하고,
    팀에서 회원을 찾으려면 팀 객체는 회원의 참조 값을 가지고 있어야하기 때문이다.
    즉, 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다.
    객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.
    양방향에서 서로 PK가 될 순 없다. 한 쪽은 FK가 되어야 한다(연관관계의 주인 지정)
    주인이 아닌 쪽은 읽기만 가능하다. 값을 변경해도 DB에 반영되지 않는다.
    주인은 mappedBy 속성을 사용하지 않고, 주인이 아닌 경우만 mappedBy 속성으로 주인을 지정한다.
    외래키가 있는 곳을 주인으로 정해라 테이블 관점에서 MEMBER는 TEAM의 참조 값을 가지고 있지만, TEAM 테이블은 MEMBER 참조 값이 없기 때문이다.

테이블 연관관계
    회원 <-> 팀의 연관관계 1개(양방향)
    외래 키 하나로 두 테이블의 연관관계를 관리한다.(양쪽으로 조인할 수 있다.)

양방향 매핑 시 가장 많이 하는 실수
(연관관계의 주인에 값을 입력하지 않고, 주인이 아닌 객체에 값을 세팅함.)
양방향의 경우 주인에만 값을 세팅해도 되지만, 가급적 연관관계의 주인 뿐만 아니라 참조 엔티티에도 값을 변경할 것.(양방향 모두 값을 변경할 것.)
양방향 모두 추가할 경우 연관관계 편의 메서드 사용 일 혹은 다에 넣어도 상관없으나, 양 쪽에 넣으면 안됨.
양방향 매핑 시에 무한 루프를 조심하기.(toString(), lombok, JSON 생성 라이브러리) lombok toString 가급적 피할것.

Member.class
public void changeTeam(Team team){
    this.team = team;
    team.getMembers().add(this);
}
or
Team.class
public void addMember(Member member){
    member.setTeam(this);
    members.add(member);
}

정리
단방향 매핑만으로도 이미 연관관계 매핑 완료 **중요**
양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
JPQL에서 역방향으로 탐색할 일이 많음.
단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨.(테이블에 영향을 주지 않음.)
양방향 연관관계를 만드는 이유는 개발자의 편의를 위해서이다. 단방향으로 충분히 양방향 연관관계를 풀어 나갈 수 있다.


OneToMany의 List<Order> orders = new ArrayList<>();에서 new ArrayList<>();는 관례이다.